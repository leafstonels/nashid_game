<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Flappy Game</title>
<style>
  body {
    margin: 0;
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
  }
  canvas {
    background: #70c5ce;
    display: block;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ---------------- ASSETS ----------------
let bg = new Image(); bg.src = "bg.png";
let ground = new Image(); ground.src = "ground.png";
let birdImg = new Image(); birdImg.src = "bird.png";
let pipeTop = new Image(); pipeTop.src = "pipeTop.png";
let pipeBottom = new Image(); pipeBottom.src = "pipeBottom.png";

let flapSound = new Audio("flap.mp3");
let pointSound = new Audio("point.mp3");
let deathSounds = [new Audio("death1.mp3"), new Audio("death2.mp3")];

// ---------------- PRELOAD ----------------
let assetsLoaded = 0;
let totalAssets = 5 + 2 + deathSounds.length;
let showMenu = false;
let failedAssets = [];

function markLoaded(name, success) {
  assetsLoaded++;
  if (!success) failedAssets.push(name);
  if (assetsLoaded >= totalAssets) {
    setTimeout(() => { showMenu = true; }, 300);
  }
}

// preload images
[
  ["bg.png", bg],
  ["ground.png", ground],
  ["bird.png", birdImg],
  ["pipeTop.png", pipeTop],
  ["pipeBottom.png", pipeBottom]
].forEach(([name, img]) => {
  img.onload = () => markLoaded(name, true);
  img.onerror = () => markLoaded(name, false);
});

// preload sounds
[
  ["flap.mp3", flapSound],
  ["point.mp3", pointSound],
  ...deathSounds.map((s,i)=>[`death${i+1}.mp3`, s])
].forEach(([name, snd]) => {
  let loaded = false;
  const done = (success) => { if (!loaded) { loaded = true; markLoaded(name, success); } };
  snd.addEventListener("loadeddata", () => done(true));
  snd.addEventListener("error", () => done(false));
  setTimeout(() => done(false), 2000); // fallback
});

// final fallback: always start after 5s
setTimeout(() => { if (!showMenu) showMenu = true; }, 5000);

// ---------------- GAME STATE ----------------
let gameOver = false;
let started = false;
let frame = 0;
let pipes = [];
let gap = 120;
let groundX = 0;
let score = 0;
let highScore = 0;

let bird = { 
  x: 50, y: 150, width: 68, height: 48, 
  gravity: 0.25, lift: -6, velocity: 0 
};

function resetGame() {
  bird.y = 150;
  bird.velocity = 0;
  pipes = [];
  score = 0;
  frame = 0;
  gameOver = false;
  started = true;
}

// ---------------- INPUT ----------------
document.addEventListener("keydown", e => {
  if (e.code === "Space") {
    if (!started && showMenu) resetGame();
    else if (!gameOver) {
      bird.velocity = bird.lift;
      flapSound.play();
    } else {
      resetGame();
    }
  }
});

canvas.addEventListener("mousedown", () => {
  if (!started && showMenu) resetGame();
  else if (!gameOver) {
    bird.velocity = bird.lift;
    flapSound.play();
  } else {
    resetGame();
  }
});

// ---------------- UPDATE ----------------
function update() {
  bird.velocity += bird.gravity;
  bird.y += bird.velocity;

  if (frame % 90 === 0) {
    let minY = 80;
    let maxY = canvas.height - gap - 160;
    let pipeY = Math.floor(Math.random() * (maxY - minY)) + minY;
    pipes.push({ x: canvas.width, y: pipeY, scored: false });
  }

  pipes.forEach(p => p.x -= 2);
  pipes = pipes.filter(p => p.x + pipeTop.width > 0);

  pipes.forEach(p => {
    if (!p.scored && p.x + pipeTop.width < bird.x) {
      score++;
      p.scored = true;
      pointSound.play();
    }

    if (
      bird.x < p.x + pipeTop.width &&
      bird.x + bird.width > p.x &&
      (bird.y < p.y || bird.y + bird.height > p.y + gap)
    ) {
      playRandomDeathSound();
      gameOver = true;
      highScore = Math.max(highScore, score);
    }
  });

  if (bird.y + bird.height > canvas.height - ground.height) {
    playRandomDeathSound();
    gameOver = true;
    highScore = Math.max(highScore, score);
  }

  groundX = (groundX - 2) % canvas.width;
  frame++;
}

function playRandomDeathSound() {
  let s = deathSounds[Math.floor(Math.random() * deathSounds.length)];
  s.currentTime = 0;
  s.play();
}

// ---------------- DRAW ----------------
function draw() {
  if (!showMenu) {
    // loading screen
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.font = "20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Loading... " + Math.floor((assetsLoaded / totalAssets) * 100) + "%", canvas.width/2, canvas.height/2);

    if (failedAssets.length > 0) {
      ctx.font = "14px Arial";
      ctx.fillStyle = "red";
      ctx.fillText("Missing: " + failedAssets.join(", "), canvas.width/2, canvas.height/2 + 40);
    }
    return;
  }

  ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);

  pipes.forEach(p => {
    ctx.drawImage(pipeTop, p.x, p.y - pipeTop.height);
    ctx.drawImage(pipeBottom, p.x, p.y + gap);
  });

  ctx.drawImage(birdImg, bird.x, bird.y, bird.width, bird.height);

  ctx.drawImage(ground, groundX, canvas.height - ground.height);
  ctx.drawImage(ground, groundX + canvas.width, canvas.height - ground.height);

  ctx.fillStyle = "#fff";
  ctx.font = "20px Arial";
  ctx.textAlign = "center";

  if (!started) {
    ctx.font = "30px Arial";
    ctx.fillText("Flappy Game", canvas.width/2, canvas.height/2 - 50);
    ctx.font = "20px Arial";
    ctx.fillText("Press Space or Tap to Start", canvas.width/2, canvas.height/2);
  } else if (gameOver) {
    ctx.fillText("Game Over", canvas.width/2, canvas.height/2 - 40);
    ctx.fillText("Score: " + score, canvas.width/2, canvas.height/2);
    ctx.fillText("High Score: " + highScore, canvas.width/2, canvas.height/2 + 30);
    ctx.fillText("Press Space or Tap to Restart", canvas.width/2, canvas.height/2 + 80);
  } else {
    ctx.fillText(score, canvas.width/2, 50);
  }
}

// ---------------- LOOP ----------------
function loop() {
  if (started && !gameOver) update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
